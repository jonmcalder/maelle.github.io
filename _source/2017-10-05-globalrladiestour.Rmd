---
layout: post
title: "The R-Ladies global tour"
comments: true
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE, 
                      cache = TRUE) 
```

It was recently brought to my attention by [Hannah Frick](https://twitter.com/hfcfrick) that there are now sooo many R-Ladies chapters around the world! [R-Ladies](http://rladies.org/) is a world-wide organization to promote gender diversity in the R community, and I'm very grateful to be part of this community through which I met so many awesome ladies! Since we're all connected, it has now happened quite a few times that R-Ladies gave talks at chapters outside of their hometowns. An R-Lady from Taiwan giving a talk in Madrid while on a trip in Europe and another one doing the same in Lisbon, an R-Lady from San Francisco presenting at the London and Barcelona chapters thanks to a conference on the continent, an R-Lady from Uruguay sharing her experience for the New York City and San Francisco chapters... It's like rockstars tours! 

Therefore we  R-Ladies often joke about doing an exhaustive global tour. Hannah made me think about this tour again... If someone were to really visit all of the chapters, what would be the shortest itinerary? And could we do a cool gif with the results? These are the problems we solve here.

<!--more-->

# Getting the chapters

To find all chapters, I'll scrape [this webpage](https://www.meetup.com/topics/r-ladies/all/) because I'm too impatient to wait for the cool [`meetupr` package](https://github.com/rladies/meetupr/) to include the Meetup API topic endpoint and because I'm too lazy to include it myself. I did open [an issue](https://github.com/rladies/meetupr/issues/13) though. Besides, I was allowed to scrape the page:

```{r}
robotstxt::paths_allowed("https://www.meetup.com/topics/")
```

Yesss. So let's scrape!

```{r}
library("rvest")

link <- "https://www.meetup.com/topics/r-ladies/all/"
page_content <- read_html(link)
css <- 'span[class="text--secondary text--small chunk"]'

chapters <-  html_nodes(page_content, css) %>% html_text(trim = TRUE)
chapters <- stringr::str_replace(chapters, ".*\\|", "")
chapters <- trimws(chapters)
head(chapters)

# Montenegro
chapters[chapters == "HN\\, Montenegro"] <- "Herceg Novi, Montenegro"
```

# Geolocating the chapters

Here I decided to use a [nifty package](https://github.com/ropensci/opencage) to the awesome OpenCage API. Ok, this is my own package. But hey it's really a good geocoding API. And the package was [reviewed for rOpenSci by Julia Silge](https://github.com/ropensci/onboarding/issues/36)!

Given that there are many chapters but not that many (`r length(chapters)` to be exact), I could inspect the results and check them.

```{r}
geolocate_chapter <- function(chapter){
  # query the API
  results <- opencage::opencage_forward(chapter)$results
  # deal with Strasbourg
  if(chapter == "Strasbourg, France"){
    results <- dplyr::filter(results, components.city == "Strasbourg")
  }
  # get a CITY
  results <- dplyr::filter(results, components._type == "city")
  # sort the results by confidence score 
  results <- dplyr::arrange(results, desc(confidence))
  # choose the first line among those with highest confidence score
  results <- results[1,]
  # return only long and lat
  tibble::tibble(long = results$geometry.lng,
                 lat = results$geometry.lat,
                 chapter = chapter, 
                 formatted = results$formatted)
}

chapters_df <- purrr::map_df(chapters, geolocate_chapter)

# add an index variable
chapters_df <- dplyr::mutate(chapters_df, id = 1:nrow(chapters_df))

knitr::kable(chapters_df[1:10,])
```


# Planning the trip

I'll use the [`ompr` package](https://github.com/dirkschumacher/ompr) inspired by this fantastic use case, ["Boris Johnsonâ€™s fully global itinerary of apology"](https://rstudio-pubs-static.s3.amazonaws.com/199542_7f23d4edf6094d89b386e9c875d09a1c.html) -- be careful, the code of this use case is slightly outdated. The `ompr` package supports modeling and solving [Mixed Integer Linear Programs](https://en.wikipedia.org/wiki/Integer_programming). I got a not so bad notion of what this means by looking [at this collection of use cases](https://dirkschumacher.github.io/ompr/articles/index.html). I'll just follow the same steps as [in the traveling salesman vignette](https://dirkschumacher.github.io/ompr/articles/problem-tsp.html), thanks Dirk!

We first need to compute the distance between chapters.

```{r}
distance <- geosphere::distm(as.matrix(dplyr::select(chapters_df, long, lat)), fun = geosphere::distGeo) %>% 
  round

```

Then the cool part comes, building the model! Dirk has made `ompr` particularly user-friendly. Obviously in my case I just need to copy paste stuff but if I were to create a model from scratch using `ompr` I wouldn't need to write mathematical formulas myself.

```{r}
library("ompr")

n <- nrow(chapters_df)
# Model based on the answer by Alan Erera at http://www.or-exchange.com/questions/11784/solving-tsp-using-solvers/11943
model <- MIPModel() %>%
  
  # we create a variable that is 1 iff we travel from city i to j
  add_variable(y[i, j], i = 1:n, j = 1:n, type = "binary") %>%
  
  # flow from i to j
  add_variable(x[i, j], i = 1:n, j = 1:n, lb = 0, ub = n - 1) %>%
  
  # minimize travel distance
  set_objective(sum_expr(distance[i, j] * y[i, j], i = 1:n, j = 1:n), "min") %>%
  
  # you cannot go to the same city
  set_bounds(y[i, i], ub = 0, i = 1:n) %>%
  
  # leave each city
  add_constraint(sum_expr(y[i, j], j = 1:n) == 1, i = 1:n) %>%
  
  # visit each city
  add_constraint(sum_expr(y[i, j], i = 1:n) == 1, j = 1:n) %>%
  
  # ensure the flow
  add_constraint(x[i, j] <= (n - 1) * y[i, j], i = 1:n, j = 1:n) %>%
  
  # each node consumes -1
  add_constraint(sum_expr(x[j, i], j = 1:n) == sum_expr(x[i, j], j = 1:n) + 1, i = 2:n) %>% 
  
  # source supply
  add_constraint(sum_expr(x[1, j], j = 1:n) == n - 1)

model

```

Wait did I say building the model is cool? Solving it even more so! `ompr` works with several solvers, Symphony being one of them. Dirk told me it would be faster than GLPK. We used to work together so he knows how patient I am (hint: not at all).

```{r, eval = TRUE}
library("ompr.roi")
library("ROI.plugin.symphony")
result <- solve_model(model, with_ROI(solver = "symphony", verbose = TRUE))

```


```{r, echo = FALSE, eval = TRUE}
save(result, file = "data/globalrladiestour.RData")
```

After that we can get a tidyverse-compatible `data.frame`, what a nice package!

```{r}
solution <- get_solution(result, x[i, j]) %>% 
  dplyr::filter(value > 0) 
knitr::kable(solution[1:2,])

```

And here is how to link the solution to our initial chapters `data.frame`.

```{r}
paths_mess <- dplyr::select(solution, i, j) %>% 
  dplyr::rename(from = i, to = j) 

# couldn't find more elegant solution
# to have the right order
paths <- paths_mess[1,]
for (row in 2:nrow(paths_mess)){
  paths <- rbind(paths,
                 paths_mess[paths_mess$from == paths$to[row - 1],])
}

paths <- paths %>%
  dplyr::mutate(trip_id = row_number()) %>% 
  tidyr::gather(property, idx_val, from:to) %>% 
  dplyr::mutate(idx_val = as.integer(idx_val)) %>% 
  dplyr::inner_join(chapters_df, by = c("idx_val" = "id"))
paths <- dplyr::arrange(paths, trip_id)
knitr::kable(paths[1:3,])
```


# Plotting the tour, boring version

I'll start by plotting the trips as it is done in the vignette, i.e. in a static way. Note: I used Dirk's code in the Boris Johnson use case for the map, and [had to use a particular branch of `ggalt`](https://github.com/hrbrmstr/ggalt/issues/33) to get `coord_proj` working.


```{r}
library("ggplot2")
library("ggalt")
library("ggthemes")
library("ggmap")
world <- map_data("world") %>% dplyr::filter(region != "Antarctica")

ggplot(data = paths, aes(long, lat)) + 
  geom_map(data = world, map = world, aes(long, lat, map_id = region), 
           fill = "white", color = "darkgrey", alpha = 0.8, size = 0.2) + 
  geom_path(aes(group = trip_id), color = "#88398A") + 
  geom_point(data = chapters_df, color = "#88398A", size = 0.8) + 
  theme_map() + 
  coord_proj("+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs") + 
  ggtitle("R-Ladies global tour", 
          subtitle = paste0(format(round(result$objective_value/ 1000), big.mark = ","), " km"))

```

Dirk told me the map would look better with great circles instead of straight lines so I googled a bit around, asked for help [on Twitter](https://twitter.com/ma_salmon/status/915515028702466048) before finding [this post](http://strimas.com/spatial/long-flights/).

```{r}
library("geosphere")
# keeping the distance for later
paths <- dplyr::mutate(paths,
                       distance = geosphere::distGeo(cbind(lag(long), lag(lat)),
                                                     cbind(long, lat)))
# find points on great circles between chapters
gc_routes <- gcIntermediate(paths[seq(from = 1, to = nrow(paths) - 1,
                                      by = 2), c("long", "lat")],
                            paths[seq(from = 2, to = nrow(paths),
                                      by = 2), c("long", "lat")],
                            n = 360, addStartEnd = TRUE, sp = TRUE, 
                            breakAtDateLine = TRUE)
gc_routes <- SpatialLinesDataFrame(gc_routes, 
                                   data.frame(id = paths$id,
                                              stringsAsFactors = FALSE))
gc_routes_df <- fortify(gc_routes)
# join the resulting data.frame with paths
# in order to have a distance and the destination of the trip
gc_routes_df <- dplyr::mutate(gc_routes_df, id = as.numeric(id))
dist_paths <- dplyr::filter(paths, distance != 0)
dist_paths <- dplyr::select(dist_paths, chapter, distance, trip_id)
gc_routes_df <- dplyr::left_join(gc_routes_df, dist_paths, by = c("id" = "trip_id"))
gc_routes_df <- dplyr::arrange(gc_routes_df, id, order)
```


```{r}

# first and last points are duplicates
gc_routes_df <- dplyr::filter(gc_routes_df,
                              order != 1)


ggplot(data = paths, aes(long, lat)) + 
  geom_map(data = world, map = world, aes(long, lat, map_id = region), 
           fill = "white", color = "darkgrey", alpha = 0.8, size = 0.2) + 
  geom_path(data = gc_routes_df, 
            aes(long, lat, group = group), alpha = 0.5, color = "#88398A") + 
  geom_point(data = chapters_df, color = "#88398A", size = 0.8) + 
  theme_map() + 
  coord_proj("+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs") + 
  ggtitle("R-Ladies global tour", 
          subtitle = paste0(format(round(result$objective_value/ 1000), big.mark = ","), " km"))

```

Ok this is much, much nicer, it was worth the search.

# Plotting the tour, magical version

And now I'll use `magick` because I want to add a small bee flying around the world. Why a bee? Well because it was a nice looking flying emoji. By the way if this global tour were to happen I reckon that one would need to donate a lot of money to rainforest charities or the like, because it'd have a huge carbon footprint! Too bad really, I don't want my gif to promote planet destroying behaviours.

To make the gif I used code similar to the one [shared in this post](http://www.masalmon.eu/2017/02/18/complot/) but in a better version thanks to Jeroen who told me to [read the vignette again](https://cran.r-project.org/web/packages/magick/vignettes/intro.html#animated_graphics). Not saving PNGs saves time!

But first let's create a `data.frame` with a number of points between cities dependent on the distance between them.

```{r}
# data.frame with number of points between cities
# proportional to distance
gc_routes_df_points <- gc_routes_df
gc_routes_df_points <- dplyr::group_by(gc_routes_df_points, id)
gc_routes_df_points <- dplyr::filter(gc_routes_df_points,
                              order %in% seq(2, to = 360,
                                             by = round(359/(distance[1]/100000))))
gc_routes_df_points <- dplyr::ungroup(gc_routes_df_points)

```

And then let's create the gif.

```{r}
library("emojifont")
load.emojifont('OpenSansEmoji.ttf')
library("magick")
gc_routes_df_points <- dplyr::mutate(gc_routes_df_points, 
                              moment = 1:nrow(gc_routes_df_points))
plot_one_moment <- function(moment, word,
                            chapters_df, 
                            gc_routes_df){
  p <- ggplot(data = paths, aes(long, lat)) + 
  geom_map(data = world, map = world, aes(long, lat, map_id = region), 
           fill = "white", color = "darkgrey", alpha = 0.8, size = 0.2) + 
  geom_path(data = gc_routes_df, 
            aes(long, lat, group = group), alpha = 0.5, color = "#88398A") + 
  geom_point(data = chapters_df, color = "#88398A", size = 0.8) + 
  theme_map(base_size =20) + 
  coord_proj("+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs") + 
  ggtitle(paste0("R-Ladies global tour, next stop: ",
                 gc_routes_df_points[gc_routes_df_points$moment == moment,]$chapter), 
          subtitle = paste0(format(round(result$objective_value/ 1000), big.mark = ","), " km"))+ 
    geom_text(data = gc_routes_df_points[gc_routes_df_points$moment == moment,], 
            aes(x = long, 
                y = lat,
                label = emoji("bee")),
            family="OpenSansEmoji",
                size = 10)
  
  print(p)
}

img <- image_graph(800, 400, res = 96)
out <- purrr::walk(gc_routes_df_points$moment,
     plot_one_moment, word = word,
      chapters_df = chapters_df, 
      gc_routes_df = gc_routes_df) 
dev.off()
image_animate(img, fps=0.04) %>%
  image_write("rladiesglobal.gif")
```

![](https://github.com/masalmon/masalmon.github.io/blob/master/_source/rladiesglobal.gif?raw=true)

How cute is this bee travelling the world? Now I hope Hannah will be happy with the gif, because it took a while to compute the whole thing, and now I'd prefer dreaming of being the bee and meeting awesome R-Ladies in many chapters!
